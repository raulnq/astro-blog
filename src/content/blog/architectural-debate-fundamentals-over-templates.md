---
title: "Software Architecture Debate: Beyond Clean, Hexagonal, and Onion Diagrams to Core Fundamentals"
description: "A recent discussion highlights that true software architectural solidity and future-proofing stem from understanding coupling, cohesion, and managing volatility, rather than rigid adherence to specific diagrams or templates. The conversation underscores the importance of context and underlying principles over prescriptive architectural styles."
date: 2025-11-19
tags: ["software architecture","clean architecture","hexagonal architecture","coupling","cohesion"]
source: "https://www.youtube.com/watch?v=Thzz5bvUI40"
---
Derrick Martin of codepinion.com recently challenged a prevalent Reddit debate concerning the "most solid and futureproof" software architecture among Clean, Hexagonal, and Onion styles. Martin argues that the discussion, and many of its comments, miss the fundamental intent behind these architectural patterns. He asserts that all three architectural styles fundamentally aim to achieve the same goal: directing dependencies, isolating the core business logic, and thereby providing system stability. The crucial "why" often goes unaddressed, leading to a misconception that these are prescriptions rather than mental models for managing complexity. The core problem these architectures address is the protection of valuable business capabilities from volatile external dependencies, ensuring the stability of the system's most critical components.

Martin emphasizes that understanding "volatility" and "blast radius" is paramount. These patterns are not rigid blueprints but frameworks to manage coupling — the degree to which components rely on each other — and achieve high cohesion, where elements within a module logically belong together, centered on business capabilities rather than technical concerns. He illustrates that blind abstraction, often justified by a vague "you never know" rationale, can introduce "useless indirection" if not warranted by a high blast radius or volatile dependency. The utility of applying such patterns, like introducing an IEmailSender interface, depends entirely on the system's context, the number of usages of a volatile dependency, and the potential pain of change. Ultimately, true future-proofing and maintainability emerge from a deep understanding and diligent management of cohesion and coupling within a system, rather than slavishly following architectural templates, especially in simpler applications like CRUD services where over-engineering can complicate changes.